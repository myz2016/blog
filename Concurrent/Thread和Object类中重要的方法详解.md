# Thread和Object类中重要的方法详解

## 方法概览

| 类     | 方法名                    | 简介                                                         |
| ------ | ------------------------- | ------------------------------------------------------------ |
| Thread | sleep相关                 | 本表格的“相关”，指的重载方法，也就是方法名相同，但是参数不同，例如sleep有多个方法，只是参数不同，实际作用大同小异 |
|        | join                      | 等待其他线程执行完毕                                         |
|        | yield相关                 | 放弃已经获取到的cpu资源                                      |
|        | currentThread             | 获取当前执行线程的引用                                       |
|        | start，run相关            | 启动线程相关                                                 |
|        | interrupt相关             | 中断线程                                                     |
|        | stop，suspend，resume相关 | 已废弃                                                       |
| Object | wait/notify/notifyAll相关 | 让线程暂时休息和唤醒                                         |

## wait、notify、notifyAll作用及用法

*  阻塞阶段

调用 wait 方法后，线程就进入阻塞状态，直到以下4种情况之一发生时，才会被唤醒

1. 另一个线程调用这个对象的 notify() 方法且刚好被唤醒的是本线程
2. 另一个线程调用这个对象的 notifyAll() 方法
3. 过了 wait(long timeout) 规定超过的时间，如果传入0就是永久等待
4. 线程自身调用了 interrupt() 



* 唤醒阶段

notify() 会唤醒单个正在等待某对象 monitor 锁的线程，唤醒时如果有多个线程都在等待，它只会选取其中一个。它被唤醒之后，这个线程就不在是等待的状态，它会重新参与到线程的调度中，等到时机合适被调度进来，它就可以继续执行了。注意这里说的是等到时机合适被调度进来才会继续执行，而不是被唤醒后就立即执行。

notifyAll() 会唤醒所有正在等待某对象 monitor 锁的线程，唤醒之后至于那个线程会获取到锁，这要依赖于操作系统的调度。

wait() 与 notify()、notifyAll() 方法必须在 synchronized 修饰的代码块或方法中调用。



* 遇到中断

阻塞状态时遇到中断，会抛出 InterruptedException 异常，然后释放锁。