# 线程8大核心基础知识

## 实现多线程的方法到底是1种2种还是4种

1. 继承 Thread 类

2. 实现 Runnable 接口

## 哪种实现方式更好？

​	方法2（Runnable），为什么？从下面几点阐述：

1. 从代码架构角度
   * 这里分为两件事情，第一件事情是具体的任务，也就是 run() 方法里的内容，而第二个事情是跟整个线程生命周期相关的，比如创建、运行、销毁线程，这个是 Thread 类要去做的事情，这两个事情目的不一样，站在架构的角度应该去解耦，所以应该用实现 Runnable 接口这种方式创建线程。
2. 新建线程的损耗
   * 如果使用继承 Thread 的方式，每次新建任务都要 new 一个 Thread 对象，损耗比较大，因为每次都要去新建一个线程，执行完了还要销毁；而使用 Runnable 的方式，只需要传入不同的实现了 Runnable 类的对象即可，可以反复利用同一个线程，线程池就是这么做的。这样一来，我们用于线程声明周期的损耗就减少了。
3. Java 不支持双继承
   * 有利于扩展，Java 语言不支持多继承，继承了一个类后，就无法再继承其他类，如果以后需要继承公共的基类，就做不到了，限制了扩展性；而对于接口，则可以多实现。

同时调用两种方法会怎样？

​	会执行继承 Thread 类重写的 run 方法

## 总结：最精准的描述

* 创建线程的方式通常可以分为两类，Oracle 官方也是这么说的
* 准确的讲，创建线程只有一种方式，那就是构造 Thread 类，而实现线程的执行单元有两种方式
  * 方法一，实现 Runnable 接口的 run 方法，并把 Runnable 实例传递给 Thread 类
  * 方法二，重写 Thread 类的 run 方法（继承 Thread 类）

## 如何正确停止线程

* 原理介绍：使用 interrupt 来通知，而不是强制

### run 方法内没有 sleep 或 wait 方法

```java
/**
 * run 方法内没有 sleep 或 wait 方法时，停止线程
 * @author mfh
 * @date 2020/4/13 21:06
 */
public class RightWayStopThreadWithoutSleep implements Runnable {

    @Override
    public void run() {
        int num = 0;
        /**
         * Thread.currentThread().isInterrupted()
         * 实时监控着，观察着此线程是否被通知中断，如果通知了，就不再执行。
         * 这就是响应中断，如果此处不响应中断，线程对象调用 interrupt()
         * 是没有任何作用的
         */
        while (!Thread.currentThread().isInterrupted() && num <= Integer.MAX_VALUE / 2) {
            if (num % 100_00 == 0) {
                System.out.printf("%d 是 10000 的倍数\n", num);
            }
            num++;
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(new RightWayStopThreadWithoutSleep());
        thread.start();
        /**
         * 让子线程执行 1 秒，如果上来就中断，那么将不会打印任何内容
         */
        Thread.sleep(1000);
        /**
         * run 方法内如果没有响应中断，此处调用 interrupt() 是没有任何作用的
         */
        thread.interrupt();
    }
}
```

### run 方法内有 sleep 或 wait 方法

```java
package threadcoreknowledge.stopthreads;

/**
 * run 方法内有 sleep 或 wait 方法时，停止线程
 *
 * @author mfh
 * @date 2020/4/13 21:29
 */
public class RightWayStopThreadWithSleep {
    public static void main(String[] args) throws InterruptedException {
        Runnable r = () -> {
            int num = 0;
            try {
                while (!Thread.currentThread().isInterrupted() && num <= Integer.MAX_VALUE / 2) {
                    if (num % 100 == 0) {
                        System.out.printf("%d 是 100 的倍数\n", num);
                    }
                    num++;
                }
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        };
        Thread thread = new Thread(r);
        thread.start();
        Thread.sleep(500);
        thread.interrupt();
    }
    /**
     * 当线程正在休眠的过程中，如果收到了中断信号，便会响应这个中断，它响应中断的方式比较特殊，是通过抛出异常的方式来响应中断。
     * 这是当程序带有 sleep 或者 wait 这种能让线程进行阻塞的方法时，我们需要中断的时候需要注意的情况。
     * 它会让调用者把 interruptException 异常给处理掉，我们选择 catch 的方式处理掉之后，就可以做到，当线程进入阻塞过程中，依
     * 然能够响应中断。
     */
}
```

### 每次迭代都阻塞线程的情况

```java
package threadcoreknowledge.stopthreads;

/**
 * 每次迭代都阻塞线程的情况
 * @author mfh
 * @date 2020/4/13 22:11
 */
public class RightWayStopThreadWithSleepEveryLoop {
    public static void main(String[] args) throws InterruptedException {
        Runnable r = () -> {
            int num = 0;
            try {
                while (num <= Integer.MAX_VALUE / 2) {
                    if (num % 100 == 0) {
                        System.out.printf("%d 是 100 的倍数\n", num);
                    }
                    Thread.sleep(10);
                    num++;
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        };
        Thread thread = new Thread(r);
        thread.start();
        Thread.sleep(5000);
        thread.interrupt();
    }
    /**
     * 如果在执行过程中，每次循环都会调用 sleep 或 wait 等方法，那么不需要加入 Thread.currentThread().isInterrupted() ，每次都检查是否已中断，这是多余的判断。
     * 即使没有这样的判断，也能中断线程。
     */
}
```

### while 内 try..catch 不能中断线程

```java
package threadcoreknowledge.stopthreads;

/**
 * @author mfh
 * @date 2020/4/14 21:20
 */
public class CantInterrupt {
    public static void main(String[] args) throws InterruptedException {
        Runnable runnable = () -> {
            int num = 0;
            while (num <= 10000 && !Thread.currentThread().isInterrupted()) {
                if (num % 100 == 0) {
                    System.out.printf("%d是100的倍数\n", num);
                }
                num++;
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        };
        Thread thread = new Thread(runnable);
        thread.start();
        Thread.sleep(5000);
        thread.interrupt();
    }
    /**
     * while 内 try..catch，即使加入 Thread.currentThread().isInterrupted() 判断，循环也不会中断，抛出异常后会继续执行
     * 原因：java 设计 sleep 函数时，有这样一个理念，当它一旦响应中断，于是便会把线程的 interrupt 标记位清除，也就是说确实是
     * 在 sleep 过程中收到了中断，并且 catch 住了并打印了异常栈，但 sleep 设计的理念导致 interrupt 标记位会被清除，所以再次
     * 循环时，Thread.currentThread().isInterrupted() 判断就不起作用了，因为中断标记位已经被清除了，它检查不到任何被中断的
     * 迹象，导致程序不能退出。
     */
}
```

## 最佳实践

```java
package threadcoreknowledge.stopthreads.bestpractice;

/**
 * 最佳实践：catch 了 InterruptException 之后的优先选择：在方法签名中抛出异常
 * @author mfh
 * @date 2020/4/14 22:11
 */
public class RightWayStopThreadInProd implements Runnable {

    @Override
    public void run() {
        while (true && !Thread.currentThread().isInterrupted()) {
            System.out.printf("业务处理...\n");
            throwInMethod();
        }
    }

    private void throwInMethod() {
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Thread t = new Thread(new RightWayStopThreadInProd());
        t.start();
        Thread.sleep(1000);
        t.interrupt();
    }
}
```

执行结果

```java
业务处理...
java.lang.InterruptedException: sleep interrupted
	at java.lang.Thread.sleep(Native Method)
	at threadcoreknowledge.stopthreads.bestpractice.RightWayStopThreadInProd.throwInMethod(RightWayStopThreadInProd.java:20)
	at threadcoreknowledge.stopthreads.bestpractice.RightWayStopThreadInProd.run(RightWayStopThreadInProd.java:14)
	at java.lang.Thread.run(Thread.java:748)
业务处理...
业务处理...
业务处理...
```

收到中断信号后，throwInMethod() 方法做出了响应，抛出了异常，但此方法自己处理了异常，并没有向上抛出，以至于 while 中没有感知到异常，最终结果就是虽然打印了异常，但是程序继续执行，没有停止。

正确的做法应该是 throwInMethod **向上**抛出异常，代码如下：

> P.S. 向上
>
> throwInMethod 方法相对于 run 方法，是低级方法，run  方法为高级方法。因为 run 方法是先调用的，throwInMethod 方法是后调用的，是在 run 方法内部调用的。从方法调用栈也可以看出，run 方法所处的位置比 throwInMethod 方法要高

```java
package threadcoreknowledge.stopthreads.bestpractice;

/**
 * 最佳实践：catch 了 InterruptException 之后的优先选择：在方法签名中抛出异常
 *
 * @author mfh
 * @date 2020/4/14 22:11
 */
public class RightWayStopThreadInProd implements Runnable {

    @Override
    public void run() {
        while (true && !Thread.currentThread().isInterrupted()) {
            System.out.printf("业务处理...\n");
            try {
                throwInMethod();
            } catch (InterruptedException e) {
                System.out.printf("记录日志\n");
                System.out.printf("停止程序\n");
                e.printStackTrace();
                Thread.currentThread().interrupt();
            }
        }
    }

    private void throwInMethod() throws InterruptedException {
        Thread.sleep(2000);
    }

    public static void main(String[] args) throws InterruptedException {
        Thread t = new Thread(new RightWayStopThreadInProd());
        t.start();
        Thread.sleep(1000);
        t.interrupt();
    }
}
```

执行结果：

```java
业务处理...
记录日志
停止程序
java.lang.InterruptedException: sleep interrupted
	at java.lang.Thread.sleep(Native Method)
	at threadcoreknowledge.stopthreads.bestpractice.RightWayStopThreadInProd.throwInMethod(RightWayStopThreadInProd.java:27)
	at threadcoreknowledge.stopthreads.bestpractice.RightWayStopThreadInProd.run(RightWayStopThreadInProd.java:16)
	at java.lang.Thread.run(Thread.java:748)
```



以上代码，在 while 循环中 catch 了异常，本来 while 内 try..catch 不能中断线程（因为中断标记位被清除了），但在 catch 中加入了 `Thread.currentThread().interrupt()`后，就相当于**恢复中断**，这样一来，`Thread.currentThread().isInterrupted()`判断就生效了，所以就成功中断了线程。

如果就不希望向上抛出异常，应如何处理呢？代码如下：

```java
package threadcoreknowledge.stopthreads.bestpractice;

/**
 * 最佳实践2：在 catch 子句中调用 Thread.currentThread().interrupt() 来恢复
 * 设置中断状态，以便于在后续的执行中，依然能够检查到刚才发生的中断
 *
 * @author mfh
 * @date 2020/4/14 22:11
 */
public class RightWayStopThreadInProd2 implements Runnable {

    @Override
    public void run() {
        while (true) {
            System.out.printf("业务处理...\n");
            if (Thread.currentThread().isInterrupted()) {
                System.out.printf("停止运行");
                break;
            }
            throwInMethod();
        }
    }

    private void throwInMethod() {
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
            Thread.currentThread().interrupt();
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Thread t = new Thread(new RightWayStopThreadInProd2());
        t.start();
        Thread.sleep(1000);
        t.interrupt();
    }
}
```

执行结果：

```java
业务处理...
java.lang.InterruptedException: sleep interrupted
	at java.lang.Thread.sleep(Native Method)
	at threadcoreknowledge.stopthreads.bestpractice.RightWayStopThreadInProd2.throwInMethod(RightWayStopThreadInProd2.java:26)
	at threadcoreknowledge.stopthreads.bestpractice.RightWayStopThreadInProd2.run(RightWayStopThreadInProd2.java:20)
	at java.lang.Thread.run(Thread.java:748)
业务处理...
停止运行
```

throwInMethod() 方法 catch 了异常并使用 `Thread.currentThread().interrupt()`恢复中断，程序正常结束。

​	

